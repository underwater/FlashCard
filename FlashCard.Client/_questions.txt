Q - 1  blocked by CORS policy
Basically the problem is that by design the browsers have a same-origin policy which
won't allow JS existing on page hosted on site A to make Ajax call to Site B

Cross-Origin Resource Sharing, or CORS, was built to help solve this issue.
CORS puts servers firmly in charge of who can make requests, and what type of requests are allowed.

A server has the choice to
- open up its API to all clients,
- open it up to a small number of clients, or
- prevent access to all clients.

(??) I think both the client and servers have parts to play to get this to work
The browser and the server use HTTP headers to communicate how cross-origin requests behave
A simplification of what happens
1 - browser indicates it needs to get data from another domain (adds CORS specific Header in request)
2 - Server responds by add its own response headers (either allowing or rejecting this)

Now if our API is Asp.Net port 5000 and angular client app being hosted by web pack dev server on 4200
By default this won't work, for it to work

1 - ON Client JS code (in angular service using the httpclient for example), just initiates a call to another site
the browser  detects if request is cross domain without any additional info
 (broser just adds ORIGIN RequestHeader which is now obligatory to identify the caller)
 (also The Origin header is always present on cross-origin requests, and the client has no way of setting
 or overriding the value. This is a requirement from a security standpoint:)

2 - ON Server: the foreign domain, should in its response include a header Access-Control-Allow-Origin that says that who is  allowed
(note: The value of the Access-Control-Allow-Origin header can be either a wildcard or an origin value. )
An Access-Control-Allow-Origin header with the value * indicates that any client can access this resource.
In fact, the simplest way to add CORS support to a server is to add Access-Control-Allow-Origin: * to every response

Notes:
- Using of a proxy file, is just to redirect another domain from the web pack server (i.e. without having the client be aware of the location of api server)
- When to use enableCors attribute (doesn't seem to be needed)

Question#1
The console currently when on home page, shows an error "Uncaught (in promise) undefined"... What does this refer to ?

Question#2
If you 'edit' a card from the card list, you are navigated to an edit form, the console will show an error
- ERROR TypeError: Cannot read property 'question' of undefined

Question#3 :
The "drop down control" isn't properly displaying the current topic of the card being edited (althoug it does correctly show the list of possible topics)

Question#4
I'd tried to wire up the SAVE and CANCEL handlers in the CardItemEditComponent so that they either save or cancel changes.  Although the CANCEL button seems to work, the SAVE is returning a 405 HTTP status  .... Can you have a look and let me know the right way to save changes ?

Q - how to handle api errors, (simple version)
try / catch in controller and return status code != 200

Q - How to do it globally, by
a) on server add middle ware for centralized error handling
b) display friendly message to user via global http inteceptor


Question
In reactiveForms, how come it is
- enough to use attribute binding [formControl]="question" and not the two way binding
- not needed to have banana in a box  [(formControl)]="question"
